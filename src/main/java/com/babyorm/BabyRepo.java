package com.babyorm;

import com.babyorm.annotation.ColumnName;
import com.babyorm.annotation.PK;
import com.babyorm.annotation.SchemaName;
import com.babyorm.annotation.TableName;
import com.babyorm.util.ReflectiveUtils;
import com.babyorm.util.SqlGen;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.sql.*;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static com.babyorm.util.ReflectiveUtils.*;

/**
 * A repo, baby
 * <p>
 * To make a new repo, try one of: new BabyRepo<Foo>(){}; or new BabyRepo<Foo>(Foo.class); or BabyRepo.forType(Foo.class);
 * <p>
 * You must call {@link #setGlobalConnectionSupplier(ConnectionSupplier)} or provide a ConnectionSupplier via Constructor or setter
 * If you don't, shit's gonna throw errors telling you to do this.
 * <p>
 * You may also want to provide a {@link KeyProvider} if your {@link PK} is not autogenerated.
 * we'll remind you if we need to.
 *
 * @param <T> The type of entity this repo likes the most
 */
public class BabyRepo<T> {

    /**
     * the column get methods on the ResultSet
     */
    private static final Map<Class<?>, Method> RESULTSET_GETTERS =
            addKeySuperTypes(
                    addPrimitivesToMap(
                            findMethods(
                                    ResultSet.class.getMethods(),
                                    Method::getReturnType,
                                    m -> m.getName().startsWith("get"),
                                    m -> !m.getName().startsWith("getN"),
                                    m -> m.getParameterCount() == 1,
                                    m -> m.getParameterTypes()[0].equals(String.class))));

    /**
     * the sql bind set methods on the PreparedStatement
     */
    private static final Map<Class<?>, Method> STATEMENT_SETTERS =
            addKeySuperTypes(
                    addPrimitivesToMap(
                            findMethods(
                                    PreparedStatement.class.getMethods(),
                                    m -> m.getParameterTypes()[1],
                                    m -> m.getName().startsWith("set"),
                                    m -> !m.getName().startsWith("setN"),
                                    m -> m.getParameterCount() == 2,
                                    m -> m.getParameterTypes()[0].equals(Integer.TYPE))));

    private Class<T> entityType;
    private List<Field> fields, nonKeyFields;
    private String baseSql, updateSql, insertSqlNoKey, insertSql, deleteSql;
    private static ConnectionSupplier globalConnectionSupplier;
    private ConnectionSupplier localConnectionSupplier;
    private List<Field> keyFields;
    private KeyProvider keyProvider;
    private List<String> keyFieldNames;
    private Map<Field, String> fieldToColName;
    private boolean isMultiKey, isAutoGen;
    private Map<String, Field> colNameToField;
    private Map<String, String> colNameToFieldName;

    /**
     * Pretty straight forward, can't really screw this one up.
     */
    public BabyRepo(Class<T> entityType) {
        init(entityType, null);
    }

    /**
     * @param keyProvider The key provider for the associated entity.
     */
    public BabyRepo(Class<T> entityType, KeyProvider keyProvider) {
        init(entityType, keyProvider);
    }

    /**
     * You MUST extend this class and specify your entity type on the class that directly extends
     * this class. try: new BabyRepo<Foo>(){};
     */
    public BabyRepo() {
        this((KeyProvider) null);
    }

    /**
     * You MUST extend this class and specify your entity type on the class that directly extends
     * this class. try: new BabyRepo<Foo>(){};
     */
    public BabyRepo(KeyProvider keyProvider) {
        Type genericSuperclass = this.getClass().getGenericSuperclass();
        if (genericSuperclass == null || !(genericSuperclass instanceof ParameterizedType)) {
            throw new BabyDBException("You must extend BabyRepo to use the no-arg constructor.");
        }
        init((Class<T>) ((ParameterizedType) genericSuperclass).getActualTypeArguments()[0], keyProvider);
    }

    /**
     * Use a local connection supplier instead of the global connection supplier
     */
    public BabyRepo(ConnectionSupplier connectionSupplier) {
        this();
        this.localConnectionSupplier = connectionSupplier;
    }

    /**
     * Use a local connection supplier instead of the global connection supplier
     */
    public BabyRepo(ConnectionSupplier connectionSupplier, KeyProvider keyProvider) {
        this(keyProvider);
        this.localConnectionSupplier = connectionSupplier;
    }

    /**
     * Use a local connection supplier instead of the global connection supplier
     */
    public BabyRepo(Class<T> entityType, ConnectionSupplier connectionSupplier) {
        this(entityType);
        this.localConnectionSupplier = connectionSupplier;
    }

    /**
     * Use a local connection supplier instead of the global connection supplier
     */
    public BabyRepo(Class<T> entityType, ConnectionSupplier connectionSupplier, KeyProvider keyProvider) {
        this(entityType, keyProvider);
        this.localConnectionSupplier = connectionSupplier;
    }

    /**
     * Factory method to get a new repository
     */
    public static <E> BabyRepo<E> forType(Class<E> type) {
        return new BabyRepo<>(type);
    }

    /**
     * Set the global connection supplier to use across all repositories, probably shouldn't change this at run time,
     * but it's your life, do what you want.
     */
    public static void setGlobalConnectionSupplier(ConnectionSupplier globalConnectionSupplier) {
        BabyRepo.globalConnectionSupplier = globalConnectionSupplier;
    }

    /**
     * Set the connection provider to use for this instance
     */
    public void setLocalConnectionSupplier(ConnectionSupplier localConnectionSupplier) {
        this.localConnectionSupplier = localConnectionSupplier;
    }

    private void init(Class<T> entityType, KeyProvider keyProvider) {
        this.entityType = entityType;
        this.fields = Arrays.asList(this.entityType.getDeclaredFields());
        this.fields.forEach(f -> f.setAccessible(true));
        this.keyFields = findFields(this.entityType, f -> f.getAnnotation(PK.class) != null);
        this.nonKeyFields = findFields(this.entityType, f -> f.getAnnotation(PK.class) == null);
        this.keyFields.forEach(f -> f.setAccessible(true));
        this.keyProvider = keyProvider;
        this.keyFieldNames = keyFields.stream().map(Field::getName).collect(Collectors.toList());
        this.fieldToColName = this.keyFields.stream().collect(Collectors.toMap(f -> f, this::colName));
        this.colNameToField = this.keyFields.stream().collect(Collectors.toMap(this::colName, f -> f));
        this.colNameToFieldName = this.fields.stream().collect(Collectors.toMap(fieldToColName::get, Field::getName));
        this.isAutoGen = this.keyFields.stream().map(f -> f.getAnnotation(PK.class)).anyMatch(PK::autogenerated);
        if (!isAutoGen && keyProvider == null) {
            throw new BabyDBException("You must provide a KeyProvider if your entity's PK is not autogenerated. I forgot too. :|");
        }
        verifyKeyProvider(keyProvider);
        buildCachedSqlStatements();
    }

    private String colName(Field f) {
        return Optional.ofNullable(f.getAnnotation(ColumnName.class)).map(ColumnName::value).orElseGet(f::getName);
    }

    private void buildCachedSqlStatements() {
        String tableName = determineTableName();
        this.baseSql = SqlGen.all(tableName);
        this.deleteSql = SqlGen.delete(tableName);
        List<String> orderdFields = fields.stream().map(fieldToColName::get).collect(Collectors.toList());
        this.updateSql = SqlGen.update(tableName, orderdFields);
        this.insertSqlNoKey = SqlGen.insert(tableName, nonKeyFields.stream()
                .map(fieldToColName::get
                ).collect(Collectors.toList()));
        this.insertSql = SqlGen.insert(tableName, orderdFields);
    }

    private String determineTableName() {
        String tableName = Optional.ofNullable(this.entityType.getAnnotation(SchemaName.class))
                .map(s -> s.value() + ".")
                .orElse("");
        tableName += Optional.ofNullable(this.entityType.getAnnotation(TableName.class))
                .map(TableName::value)
                .orElseGet(() -> camelCase(entityType.getSimpleName()));
        return tableName;
    }

    private String camelCase(String s) {
        return Character.toLowerCase(s.charAt(0)) + s.substring(1);
    }

    /**
     * Get one record by it's primary key
     */
    public T get(KeyProvider keyProvider) {
        verifyKeyProvider(keyProvider);
        if (this.isMultiKey) {
            return getOneByAll(((MultiValuedKeyProvider) keyProvider).nextKey());
        } else {
            return getOneByAll(keyValue(keyProvider));
        }
    }

    /**
     * select * from
     */
    public List<T> getAll() {
        return getSome(null, null, true);
    }

    /**
     * Get one record by a single column value. this is either the database column name or the field name.
     * We'll figure it out.
     *
     * @param field The field name/column name you want to look up the record by.
     * @param value The value you're searching for.
     *              If the value is a collection, an in list will be created.
     * @return The found record if any
     */
    public T getOneBy(String field, Object value) {
        return getOneByAll(Collections.singletonMap(field, value));
    }

    /**
     * Find a single record that matches ALL of the columns
     *
     * @param columnValueMap A map of column names and the values to look up by.
     *                       If the value is a collection, an in list will be created.
     * @return The found record, if any
     */
    public T getOneByAll(Map<String, Object> columnValueMap) {
        LinkedHashMap<String, Object> map = keysToColumnNames(columnValueMap);
        return getSome(SqlGen.whereAll(map), map.keySet().stream().map(map::get).collect(Collectors.toList()), false).get(0);
    }

    /**
     * Find a single record that matches ANY of the columns.
     *
     * @param columnValueMap A map of column names and the values to look up by.
     *                       If the value is a collection, an in list will be created.
     * @return The found record, if any
     */
    public T getOneByAny(Map<String, Object> columnValueMap) {
        LinkedHashMap<String, Object> map = keysToColumnNames(columnValueMap);
        return getSome(SqlGen.whereAny(map), map.keySet().stream().map(map::get).collect(Collectors.toList()), false).get(0);
    }

    /**
     * Find a many records that match a single column.
     *
     * @param field The field name/column name you want to look up the record by.
     * @param value The value you're searching for.
     *              If the value is a collection, an in list will be created.
     */
    public List<T> getManyBy(String field, Object value) {
        return getManyByAll(Collections.singletonMap(field, value));
    }

    /**
     * Find a many records that match ALL of the columns.
     *
     * @param columnValueMap A map of column/field names and the values to look up by.
     *                       If the value is a collection, an in list will be created.
     * @return The found records, if any
     */
    public List<T> getManyByAll(Map<String, Object> columnValueMap) {
        LinkedHashMap<String, Object> map = keysToColumnNames(columnValueMap);
        return getSome(SqlGen.whereAll(map), map.keySet().stream().map(map::get).collect(Collectors.toList()), true);
    }

    /**
     * Find a many records that match ANY of the columns.
     *
     * @param columnValueMap A map of column names and the values to look up by.
     *                       If the value is a collection, an in list will be created.
     * @return The found records, if any
     */
    public List<T> getManyByAny(Map<String, Object> columnValueMap) {
        LinkedHashMap<String, Object> map = keysToColumnNames(columnValueMap);
        return getSome(SqlGen.whereAny(map), map.keySet().stream().map(map::get).collect(Collectors.toList()), true);
    }

    //TODO: Handle: Entity has field X but no field with that name was found in result set. Either add a Name annotation, or make sure you selected that field.
    private List<T> getSome(String where, List<Object> values, boolean isMany) {
        try (Connection conn = getConnection()) {
            PreparedStatement st;
            String sql = baseSql + where;
            st = prepare(conn, sql, values.toArray());
            st.execute();
            return mapResultSet(st, isMany);
        } catch (SQLException e) {
            throw new BabyDBException("Failed to execute query", e);
        }
    }


    private void verifyKeyProvider(KeyProvider keyProvider) {
        if (this.isMultiKey && !(keyProvider instanceof MultiValuedKeyProvider)) {
            throw new BabyDBException("Your entity has multiple PK columns, but your keyProvider is not an instance of MultiValuedKeyProvider");
        }
    }

    private Map<String, Object> keyValue(Object id) {
        if (keyFields.size() > 1) {
            try {
                if (!(id instanceof Map)) {
                    throw new BabyDBException("You have multiple PKs on your entity. You must provide a Map<String,Object> of Name to Value mappings when querying by id.");
                }
                Map<String, Object> keyValues = (Map) id;
                return keyFields.stream().collect(Collectors.toMap(fieldToColName::get, f -> keyValues.get(fieldToColName.get(f))));
            } catch (ClassCastException e) {
                throw new BabyDBException("You must provide a Map<String,Object> of Name to Value mappings when querying by id.", e);
            }
        } else {
            return Collections.singletonMap(fieldToColName.get(keyFields.get(0)), id);
        }
    }

    private Map<String, Object> keyValueFromRecord(T record) {
        return this.keyFields.stream().collect(Collectors.toMap(fieldToColName::get, f -> getSafe(f, record)));
    }

    private LinkedHashMap<String, Object> keysToColumnNames(Map<String, Object> map){
        LinkedHashMap<String, Object> colNameValueMap = map instanceof LinkedHashMap ? (LinkedHashMap<String, Object>)map : new LinkedHashMap<>(map.size());
        map.forEach((s,o)->colNameValueMap.put(colName(s), o));
        return colNameValueMap;
    }

    private String colName(String s) {
        return Optional.ofNullable(colNameToField.get(s)).map(Field::getName).orElse(s);
    }

    private PreparedStatement prepare(Connection conn, String sql, Object... args) {
        try {
            PreparedStatement ps = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);
            int[] pos = new int[]{1};
            Arrays.stream(args)
                    .flatMap(o -> o instanceof Collection ? ((Collection) o).stream() : Stream.of(o))
                    .forEach(o -> Optional.ofNullable(STATEMENT_SETTERS.get(o.getClass()))
                            .map(s -> invokeSafe(s, ps, pos[0]++, o))
                            .orElseThrow(() -> new BabyDBException("Unsupported property type: " + o.getClass().getCanonicalName()))
                    );
            return ps;
        } catch (SQLException e) {
            throw new BabyDBException("Failed to prepare statement", e);
        }
    }

    private Connection getConnection() {
        if (localConnectionSupplier == null && globalConnectionSupplier == null) {
            throw new BabyDBException("You must set a connection supplier. Didn't read the class javadoc eh?");
        }
        return Optional.ofNullable(localConnectionSupplier)
                .map(ConnectionSupplier::getConnection)
                .orElseGet(globalConnectionSupplier::getConnection);
    }

    private List<T> mapResultSet(PreparedStatement st, boolean isMany) {
        try {
            ResultSet rs = st.getResultSet();
            List<T> many = isMany ? new ArrayList<>() : null;
            boolean hasOne = false;
            T model = null;
            while (rs.next()) {
                if (hasOne && !isMany) {
                    throw new BabyDBException("Multiple rows found for single row query");
                }
                hasOne = true;
                model = entityType.getConstructor().newInstance();
                for (Field f : fields) {
                    f.set(model, getResultValue(f, rs));
                }
                if (isMany) {
                    many.add(model);
                }
            }
            return isMany ? many : Collections.singletonList(model);
        } catch (ReflectiveOperationException | SQLException e) {
            throw new BabyDBException("Failed to map resultSet to object", e);
        }
    }

    private Object getResultValue(Field field, ResultSet resultSet) {
        Class<?> type = field.getType();
        if (!RESULTSET_GETTERS.containsKey(type)) {
            throw new BabyDBException("Unsupported model property type:" + type.getCanonicalName());
        }
        return ReflectiveUtils.invokeSafe(RESULTSET_GETTERS.get(type), resultSet, fieldToColName.get(field));
    }

    /**
     * Insert or update the given record
     *
     * @param record The record to save
     * @return The saved record. The record is retrieved from the database after saving to guarantee generated values are retrieved.
     */
    public T save(T record) {
        Objects.requireNonNull(record, "Can't save a null record");
        Map<String, Object> key = keyValueFromRecord(record);
        Object o = getOneByAll(key);
        if (o == null) {
            return insert(record);
        } else {
            T saved = get(() -> key);
            return saved != null ? update(record) : insert(record);
        }
    }

    /**
     * Update the given record
     */
    public T update(T record) {
        try (Connection conn = getConnection()) {
            LinkedHashMap<String, Object> key = new LinkedHashMap<>(keyFields.stream().collect(Collectors.toMap(Field::getName, f -> getSafe(f, record))));
            String updateSql = this.updateSql + SqlGen.whereAll(key);
            PreparedStatement st = prepare(conn, updateSql, nonKeyFields.stream().map(f->getSafe(f, record)).toArray());
            st.executeUpdate();
            KeyProvider keyProvider;
            if(this.isMultiKey){
                keyProvider = (MultiValuedKeyProvider) ()-> key;
            } else {
                keyProvider = ()->getSafe(this.keyFields.get(0), record);
            }
            return st.getUpdateCount() == 0 ? null : get(keyProvider);
        } catch (SQLException e) {
            throw new BabyDBException("Update failed", e);
        }

    }

    private String whereKeyStatement(T record, List<String> keyFieldNames) {
        return " where " + keyFieldNames.stream().map(f -> "=?").collect(Collectors.joining(" AND "));
    }

    private String fieldName(String colOrFieldName) {
        return Optional.ofNullable(colNameToField.get(colOrFieldName)).map(Field::getName)
                .orElseGet(()-> colNameToFieldName.get(colOrFieldName));
    }

    /**
     * Insert the given record into the database
     *
     * @param record The record to insert
     */
    public T insert(T record) {
        Objects.requireNonNull(record, "Can't save a null record");
        Map<String, Object> keyValue = keyValueFromRecord(record);
        boolean hasKey = keyValue != null && keyValue.size() > 0;

        try (Connection conn = getConnection()) {
            final Map<String, Object> newKey;
            if (this.isAutoGen) {
                if (this.isMultiKey) {
                    newKey = ((MultiValuedKeyProvider) keyProvider).nextKey().entrySet().stream()
                            .collect(Collectors.toMap(s->fieldName(s.getKey()), Map.Entry::getValue));
                } else {
                    newKey = Collections.singletonMap(this.keyFields.get(0).getName(), keyProvider.nextKey());
                }

                keyFields.forEach(f -> setSafe(f, record, newKey.get(f.getName())));
            } else {
                newKey = null;
            }
            PreparedStatement st = prepare(
                    conn,
                    hasKey || !this.isAutoGen ? insertSql : insertSqlNoKey,
                    getFieldValues(record, hasKey ? fields : nonKeyFields).toArray());
            st.executeUpdate();

            KeyProvider keyProvider;
            if(this.isMultiKey){
                keyProvider = (MultiValuedKeyProvider) ()-> newKey;
            } else {
                keyProvider = ()->getFieldValues(record, keyFields).get(0);
            }
            if (hasKey || !this.isAutoGen) {
                return get(keyProvider);
            } else {
                ResultSet keys;
                keys = st.getGeneratedKeys();
                if (keys.next()) {
                    if(this.isMultiKey){
                        return get(()->keyFields.stream().collect(Collectors.toMap(Field::getName, f->getResultValue(f, keys))));
                    } else {
                        return get(()->getResultValue(keyFields.get(0), keys));
                    }

                } else {
                    throw new BabyDBException("No key was returned from the db on insert for " + this.entityType.getCanonicalName());
                }
            }
        } catch (SQLException e) {
            throw new BabyDBException("Insert failed", e);
        }
    }

    /**
     * Delete a record by it's {@link PK}
     *
     * @param key The pk of the record to delete
     * @return whether a record was deleted or not
     */
    public boolean deleteByPK(Object key) {
        return deleteByAll(keyValue(key));
    }

    /**
     * Delete a record by it's {@link PK}
     *
     * @param entity The record to delete, the PK will be retrieved and used in the delete statement
     * @return whether a record was deleted or not
     */
    public boolean delete(T entity) {
        return deleteByAll(keyValue(entity));
    }

    /**
     * Delete by a specific column
     *
     * @param field The field/column name to delete by
     * @param value The value to search by
     * @return Whether any records were deleted or not
     */
    public boolean deleteBy(String field, Object value) {
        try (Connection conn = getConnection()) {
            PreparedStatement st = prepare(conn, this.deleteSql + SqlGen.whereAll(new LinkedHashMap<>(Collections.singletonMap(colName(field), value))));
            return st.executeUpdate() > 0;
        } catch (SQLException e) {
            throw new BabyDBException("Delete failed", e);
        }
    }

    /**
     * delete records that match ALL of the columns.
     *
     * @param columnValueMap A map of column names and the values to look up by.
     *                       If the value is a collection, an in list will be created.
     * @return whether any records were deleted
     */
    public boolean deleteByAll(Map<String, Object> columnValueMap) {
        try (Connection conn = getConnection()) {
            PreparedStatement st = prepare(conn, this.deleteSql + SqlGen.whereAny(keysToColumnNames(columnValueMap)));
            return st.executeUpdate() > 0;
        } catch (SQLException e) {
            throw new BabyDBException("Delete failed", e);
        }
    }

    /**
     * delete records that match ANY of the columns.
     *
     * @param columnValueMap A map of column names and the values to look up by.
     *                       If the value is a collection, an in list will be created.
     * @return whether any records were deleted
     */
    public boolean deleteByAny(Map<String, Object> columnValueMap) {
        try (Connection conn = getConnection()) {
            PreparedStatement st = prepare(conn, this.deleteSql + SqlGen.whereAll(keysToColumnNames(columnValueMap)));
            return st.executeUpdate() > 0;
        } catch (SQLException e) {
            throw new BabyDBException("Delete failed", e);
        }
    }


}